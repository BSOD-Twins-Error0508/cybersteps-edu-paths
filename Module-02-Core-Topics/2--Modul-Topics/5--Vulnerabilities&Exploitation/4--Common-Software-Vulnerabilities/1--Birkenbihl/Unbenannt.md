# Pre-Class Preparation: Common Software Vulnerabilities

Welcome to your pre-class reading. In this session, we will explore some of the most common and impactful types of software vulnerabilities that stem from how programs manage memory, interact with the operating system, and handle concurrent operations. Understanding these flaws is fundamental for both offensive and defensive cybersecurity professionals.

The vulnerabilities we'll discuss today are often found in lower-level languages like C and C++, but the underlying principles are universal. Understanding them will help you recognize similar patterns in higher-level systems and appreciate the security features built into modern languages like Python.

### What is a Software Vulnerability?

A software vulnerability is a flaw or weakness in a program's code that an attacker can exploit to produce unintended behavior. This behavior can range from crashing the program to taking full control of the underlying system. The root cause often lies in faulty assumptions made by the developer, especially regarding data received from a user. An attacker's goal is to find one of these assumptions and violate it in a way that benefits them.

Today, we'll focus on three critical vulnerability classes: Buffer Overflows, Command Injection, and Race Conditions.

### Buffer Overflow

![image.png](attachment:e7ce6747-79bf-4d5e-aa92-d1dac0df2433:image.png)

A buffer overflow is a memory-safety vulnerability. It occurs when a program attempts to write more data into a fixed-size block of memoryâ€”a "buffer"â€”than it is allocated to hold. This is one of the oldest, most studied, and most dangerous types of software vulnerabilities.

To understand this, think of a program's memory like a row of seats in a movie theater. When a program needs to store a piece of information, like a username, it reserves a specific number of seatsâ€”this is theÂ **buffer**. Crucially, other important pieces of program data are stored in the seats right next to the buffer. This could include:

- Other variables (e.g., a variable that saysÂ `is_admin = False`).
- Configuration settings loaded by the program.
- Pointers that tell the program where to find its next instruction.

The vulnerability happens when a program copies data into a buffer without checking if the data will fit. It's like having 10 people show up for 5 reserved seats. The first 5 people take their seats, and the other 5 just sit down in the next available seats, kicking out the people who were supposed to be there.

Consider this simple, vulnerable C code snippet. You don't need to know C, but pay close attention to the logic and the comments.

```
// WARNING: VULNERABLE CODE. DO NOT USE.
#include <string.h>

void vulnerable_function(char* user_input) {
    // A buffer is created in memory (e.g., 100 seats are reserved).
    char buffer[100];

    // The strcpy function copies the user's input into the buffer.
    // It has no concept of how many seats were reserved.
    // It just keeps seating people until the input runs out.
    strcpy(buffer, user_input);
}

```

TheÂ `strcpy`Â function is notoriously unsafe because it makes a dangerous assumption: that the destination buffer is large enough to hold the source string. It performs no length checks.

### The Attack

What happens if a user provides an input string that is 200 bytes long (200 "people" for 100 "seats")?

1. **Fill the buffer:**Â The first 100 bytes from the input string fill theÂ `buffer`Â perfectly.
2. **Overflow:**Â `strcpy`Â doesn't stop. It keeps copying the remaining 100 bytes from the input string into the memory adjacent to the buffer.
3. **Corrupt Memory:**Â This overflow overwrites the important data stored in the "seats" next to our buffer. An attacker can carefully craft the overflowing data to change the program's behavior.

The consequences can range from simple to severe:

- **Program Crash:**Â The most likely outcome is that the overflow corrupts critical data or pointers, causing the program to crash (a "segmentation fault"). This is a denial-of-service attack.
- **Data Manipulation:**Â An attacker could overwrite a variable, for example changingÂ `is_admin = False`Â toÂ `is_admin = True`, to elevate their privileges.
- **Execution Hijacking:**Â In the most sophisticated attacks, an attacker can overwrite a pointer that controls the program's flow, tricking it into executing malicious code (often called "shellcode") that the attacker also supplied in their input. This gives the attacker full control.

### Why doesn't this happen in Python?

This classic buffer overflow is not a direct threat when you write Python code. The reason isÂ **memory abstraction and safety**.

- **Automatic Memory Management:**Â Python handles memory allocation and deallocation for you. You don't manually manage memory buffers or pointers.
- **Bounds Checking:**Â Python's data structures, like lists and strings, are objects that know their own size. If you try to access an index that is out of bounds (e.g.,Â `my_list[99]`Â when the list only has 10 elements), Python will raise anÂ `IndexError`Â exception. It won't blindly write data past the object's boundary.
- **No Direct Pointer Access:**Â Python does not expose memory addresses to the programmer in the way C does. You cannot get a pointer to an object and manipulate the raw memory it points to.

While your PythonÂ _code_Â is safe from this specific attack, the PythonÂ _interpreter_Â itself is a program (often written in C). A vulnerability in the interpreter could theoretically be exploited, but this is extremely rare and far removed from the code you write day-to-day.

### Command Injection

A command injection vulnerability allows an attacker to execute arbitrary commands on the host operating system. This typically happens when an application takes user-supplied input and includes it in a command that gets passed to a system shell (likeÂ `bash`Â on Linux orÂ `cmd.exe`Â on Windows).

The root cause isÂ **failing to sanitize user input before passing it to a system command interpreter.**Â The application code is essentially tricking the server into running commands it was never designed to.

Imagine a web application that includes a utility to let youÂ `ping`Â a domain to check if it's online. The backend Python code might look like this:

```
# WARNING: VULNERABLE CODE. DO NOT USE.
import os

def ping_utility(domain):
    # Takes a domain from the user and pings it.
    command = f"ping -c 4 {domain}"
    # os.system() is dangerous because it invokes a system shell.
    os.system(command)

```

The developer expects a user to enter a domain likeÂ `google.com`. The executed command would beÂ `ping -c 4 google.com`.

### The Attack

Most command-line shells use special characters, called metacharacters, to chain commands together. Examples includeÂ `;`Â (run the next command regardless),Â `&&`Â (run the next command only if the first succeeds), andÂ `|`Â (pipe the output of the first command into the input of the second).

What if an attacker entersÂ `google.com; whoami`Â as the domain?

The application will construct and execute the following string:Â `ping -c 4 google.com; whoami`

The system shell sees the semicolon and understands this as two separate commands. It will first execute theÂ `ping`command. Then, it will execute theÂ `whoami`Â command, revealing the username the web server is running as. An attacker could use this to execute far more dangerous commands, like reading sensitive files (`8.8.8.8; cat /etc/passwd`) or establishing a reverse shell to gain interactive control.

### Race Condition (TOCTOU)

![image.png](attachment:e8be671c-96b4-4d86-bbec-5265bce6f34e:image.png)

A race condition is a vulnerability that arises from the sequence and timing of events. It happens when a program's correct behavior depends on the order of operations, but the program cannot guarantee that order. The operations are notÂ **atomic**â€”meaning they are not indivisible and can be interrupted.

A classic example in security is theÂ **Time-of-Check to Time-of-Use (TOCTOU)**Â vulnerability. This occurs when a program performs a security check and then, based on that check, performs an action. The vulnerability exists in the tiny window of time between the check and the action, where the state of the system can change.

Imagine a program that runs with high privileges (e.g., as theÂ `root`Â user) but is supposed to write to a file owned by a regular user.

1. **Time of Check (TOC):**Â The privileged program checks a file's properties. For example: "Does the fileÂ `/home/user/log.txt`Â exist, and is it owned by the regular user?" The check passes.
2. **The Race Window:**Â The operating system's scheduler might decide to pause the privileged program for a few milliseconds to let another process run. In this tiny gap, an attacker's script, which is running concurrently, rapidly deletesÂ `/home/user/log.txt`Â and replaces it with aÂ **symbolic link**. A symbolic link is a pointer to another file. The attacker makes their newÂ `/home/user/log.txt`Â point toÂ `/etc/shadow`, a critical system file that stores hashed user passwords.
3. **Time of Use (TOU):**Â The privileged program resumes execution. It is completely unaware of the switch that just happened. It proceeds to open what itÂ _thinks_Â isÂ `/home/user/log.txt`Â and writes data to it. Because of the symbolic link, it is now writing to (and likely corrupting)Â `/etc/shadow`, which could lock all users out of the system or grant the attacker access.

The attacker is "racing" the legitimate program, trying to change the resource in the critical moment between its validation and its use.

<aside> ðŸ“Œ

The slides for the live session can be viewed here: [https://gamma.app/docs/Module-2-Week-5-Session-4-Common-Software-Vulnerabilities-dw42jdkhige0o6k?mode=doc](https://gamma.app/docs/Module-2-Week-5-Session-4-Common-Software-Vulnerabilities-dw42jdkhige0o6k?mode=doc)

Try not to peek before class - spoilers inside!

</aside>