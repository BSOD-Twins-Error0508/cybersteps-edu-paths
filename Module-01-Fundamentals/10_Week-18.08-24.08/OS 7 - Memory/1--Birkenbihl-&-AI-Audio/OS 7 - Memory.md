Welcome to the fascinating world of computer memory! Before our live session on Operating System Memory, it's important to grasp some fundamental concepts. This preparation will guide you through what memory is, why it needs managing, and how operating systems begin to tackle this crucial task.

## What is Computer Memory?

At its core, computer memory is any physical device capable of storing information temporarily, like Random Access Memory (RAM), or permanently, like your hard drive or Solid State Drive (SSD). For our purposes in discussing operating system memory management, we're primarily interested inÂ **Main Memory**Â (RAM).

**Random Access Memory (RAM)**Â is the workspace of your computer. When you run a program (like a web browser or a game) or open a file, the data and instructions the computer needs to work with are loaded from the slower permanent storage (like your SSD or hard drive) into RAM. RAM is much faster than permanent storage, which is why it's used for active tasks. Think of RAM as your desk: you pull out the papers (data and programs) you're currently working on from your filing cabinet (hard drive) and place them on your desk for quick access.

RAM is typicallyÂ **volatile memory**, meaning its contents are lost when the power is turned off. This is in contrast toÂ **non-volatile memory**Â (like SSDs, hard drives, or Read-Only Memory (ROM)) which retains information even without power.

![image.png](attachment:a50df4fd-8970-44d1-b1c5-608613740935:image.png)

### Think about it

Why do you think computers have both fast, volatile memory (RAM) and slower, non-volatile memory (storage drives)? What would be the pros and cons of having only one type?

## The Need for Memory Management

Imagine an office with many workers (processes) all needing desk space (RAM) simultaneously. If there's no system for allocating and organizing this desk space, chaos would ensue! Workers might try to use the same spot, run out of space, or accidentally interfere with each other's documents.

An Operating System (OS) acts as the office manager for memory.Â **Memory management**Â is the process by which the OS controls and coordinates the use of computer memory, allocating portions called blocks to various running programs to optimize overall system performance.

Effective memory management is crucial for several reasons:

- **Sharing:**Â It allows multiple processes to share memory securely and efficiently.
- **Protection:**Â It prevents one process from interfering with the memory of another process or the OS itself. If one program crashes, it shouldn't bring down the entire system or corrupt other programs.
- **Efficiency:**Â It ensures that memory is used efficiently, minimizing wasted space and ensuring that processes have enough memory to run.
- **Relocation:**Â It allows programs to be loaded into different parts of memory each time they run, providing flexibility.

![image.png](attachment:74fd1b39-3ac0-45a7-8eb3-1de6bbaccc2e:image.png)

## Memory Addresses: Finding Data

Every byte of memory has a uniqueÂ **address**, just like every house on a street has a unique address. When a program needs to store or retrieve data, it uses these addresses.

There are two main types of addresses we'll encounter:

1. **Logical Address (or Virtual Address):**Â This is the address generated by the CPU as seen by a program. Each process has its own private logical address space, starting from 0 up to some maximum. This means two different programs could both refer to "address 1000", but they would be referring to different actual memory locations. This simplifies programming, as programmers don't need to know where their program will physically reside in RAM.
2. **Physical Address:**Â This is the actual address in the physical RAM chips. The OS, with the help of hardware (specifically the Memory Management Unit or MMU), translates logical addresses into physical addresses.

The concept of a separate logical address space for each process is fundamental to modern operating systems. It provides memory protection and allows for more flexible memory management techniques.

![image.png](attachment:adbb1478-c18b-4d6a-9045-453bdaacd4b7:5bc1dcfb-3b64-4aee-b5d4-5d628eb55afa.png)

### Try it yourself

(Conceptual) Think of a large library. Each book has a unique call number (its physical address on the shelf). When you look up a book in the catalog using its title (a logical identifier), the catalog tells you its call number so you can find it. How does this analogy relate to logical and physical addresses in a computer?

## A Process's View of Memory: The Address Space

When a program is run, the OS creates aÂ **process**Â and allocates it aÂ **process address space**. This is the set of logical addresses that the process can "see" and use. This address space is typically divided into several distinct segments:

- **Text Segment (or Code Segment):**Â Contains the executable instructions of the program. This area is often read-only to prevent a program from accidentally modifying its own instructions.
- **Data Segment:**Â Stores global and static variables that are initialized before the program starts.
- **BSS Segment (Block Started by Symbol):**Â Stores uninitialized global and static variables. These are typically initialized to zero by the OS when the program loads.
- **Heap:**Â This is an area of memory used for dynamic memory allocation. When a program needs more memory at runtime (e.g., to store data whose size is not known at compile time), it can request it from the heap. The programmer is responsible for managing heap memory (allocating and freeing it).
- **Stack:**Â This area is used for storing temporary data such as local variables within functions, function parameters, and return addresses when functions are called. The stack operates on a Last-In, First-Out (LIFO) principle. Each thread in a process gets its own stack.

This segmented view is a logical organization. The OS and hardware work together to map these logical segments to physical RAM.

## Basic Memory Allocation

When a new process starts, the OS needs to find a free block of physical memory large enough to hold it (or parts of it). This is calledÂ **memory allocation**. When the process terminates, its memory isÂ **deallocated**Â and becomes available for other processes.

Operating systems use various strategies to manage free memory and allocate it to processes. Some early, simple methods include:

- **Fixed Partitioning:**Â Memory is divided into fixed-size partitions. Each partition can hold one process. This is simple but can lead to wasted memory if a process is smaller than its partition (internal fragmentation) or if a process is too large to fit in any available partition.
- **Dynamic Partitioning:**Â Partitions are created dynamically to fit the size of the process. This reduces internal fragmentation but can lead to small, unusable holes of free memory between allocated blocks (external fragmentation) over time.

Modern operating systems use more sophisticated techniques like paging and segmentation, which we will explore in more detail during the live session. These techniques allow for virtual memory, where the OS can make the system appear to have more RAM than it physically does by using disk space as an overflow area.

![image.png](attachment:09df97fe-3ba2-4a73-80ee-9d058d8199d7:a7c3b730-b11e-4acc-ba7b-c370bd8d8187.png)

### Think about it

Consider dynamic partitioning. If you have a 100MB block of free memory and a process requests 30MB, you allocate it. Then another process requests 40MB, you allocate that. Now you have a 30MB free block. If a new process needs 50MB, it can't be satisfied even though there's 60MB free in total (30MB from the first allocation + 30MB from the second). This is external fragmentation. Can you think of any ways an OS might try to solve or reduce this problem?

This pre-class material should give you a solid foundation for our upcoming lesson on OS Memory. We'll build upon these concepts to understand how Windows manages memory in more detail, including virtual memory, paging, and other advanced topics.

<aside> ðŸ“Œ

The slides for the live session can be viewed here: [https://gamma.app/docs/Operating-Systems-7-Memory-xnwbowijvand7jk?mode=doc](https://gamma.app/docs/Operating-Systems-7-Memory-xnwbowijvand7jk?mode=doc)

Try not to peek before class - spoilers inside!

</aside>